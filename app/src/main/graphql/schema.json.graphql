# This file was generated based on "schema.json". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"convert lower case to uppercase"
directive @upper on FIELD_DEFINITION

"required Authorization header with valid Access Token"
directive @auth on FIELD_DEFINITION

"required Authorization header with valid Access Token and Admin role"
directive @admin on FIELD_DEFINITION

interface ICompanyInfo {
    "banner image of the company"
    background: String
    "category of the company e.g. Technology, Finance, Social Media etc"
    category: String
    "Name of the CEO"
    ceo: String
    "unique id of the company"
    companyId: String!
    "Domain name"
    domain: String
    "Email address"
    email: String
    "Facebook page url"
    facebook: String
    "Date of the company's foundation"
    founded: Date
    "Headquarters address"
    headerquarters: String
    "logo of the company"
    image: String
    "Instagram handle"
    instagram: String
    "Linkedin page url"
    linkedin: String
    "Name of the company"
    name: String
    "Phone number"
    phone: String
    "Rank of the company in Our Database"
    rank: Int
    "short description of the company"
    subtitle: String
    "Total number of urls scanned under this company"
    totalScans: Int
    "Twitter handle"
    twitter: String
    "true if the company is verified by truelink"
    verified: Boolean!
    "Official website"
    website: String
    "Youtube channel url"
    youtube: String
}

type Action {
    createdAt: Date
    link: String
    type: ActionTypes
}

type ActionOnLinkResp {
    code: Int
    message: String
    payload: Action
    success: Boolean
}

type Companies {
    background: String
    category: String
    ceo: String
    companyId: String!
    domain: String
    email: String
    facebook: String
    founded: Date
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    subtitle: String
    totalScans: Int
    twitter: String
    verified: Boolean!
    website: String
    whois: [Whois]
    youtube: String
}

type CompanyInfo implements ICompanyInfo {
    "banner image of the company"
    background: String
    "category of the company e.g. Technology, Finance, Social Media etc"
    category: String
    "|Name of the CEO"
    ceo: String
    "unique id of the company"
    companyId: String!
    "Domain name"
    domain: String
    "Email address"
    email: String
    "Facebook page url"
    facebook: String
    "Date of the company's foundation"
    founded: Date
    "Headquarters address"
    headerquarters: String
    "logo of the company"
    image: String
    "Instagram handle"
    instagram: String
    "Linkedin page url"
    linkedin: String
    "Name of the company"
    name: String
    "Phone number"
    phone: String
    "Rank of the company in Our Database"
    rank: Int
    "List of similar companies"
    similarCompanies: [SimilarCompanies]
    "short description of the company"
    subtitle: String
    "Total number of urls scanned under this company"
    totalScans: Int
    "Twitter handle"
    twitter: String
    "true if the company is verified by truelink"
    verified: Boolean!
    "Official website"
    website: String
    "Youtube channel url"
    youtube: String
}

type DNSRecords {
    "List of A records in the format of [record1, record2]"
    A: [String]
    "List of AAAA records in the format of [record1, record2]"
    AAAA: [String]
    "List of CNAME records in the format of [record1, record2]"
    CNAME: [String]
    "List of MX records in the format of [record1, record2]"
    MX: [String]
    "List of NS records in the format of [record1, record2]"
    NS: [String]
    "List of SOA records in the format of [record1, record2]"
    SOA: [String]
    "List of SRV/TXT records in the format of [record1, record2]"
    TXT: [String]
}

type DatedScanCounts {
    date: Date
    scanCounts: ScanCounts
}

type DeepScan {
    about_us: String
    author: String
    contact_us: String
    description: String
    google_site_verification: String
    heading: [String]
    keywords: String
    metaTags: String
    name: String
    og_image: String
    og_type: String
    robots: String
    title: String
}

type IpInfo {
    city: String
    "Country Initials e.g. IN, US, UK, etc"
    country: String
    "Full Country Name e.g. India, United States, United Kingdom, etc"
    country_name: String
    "server's hostname of the link"
    hostname: String
    "Destination IP of the link"
    ip: String
    latitude: String
    "Longitude and Latitude of the link's destination IP in the format of 'longitude, latitude' @deprecated"
    loc: String @deprecated(reason: "Use longitude and latitude instead")
    longitude: String
    "Organization of the link's destination IP"
    org: String
    "Postal Code"
    postal: String
    region: String
    timezone: String
}

type Link {
    "Destination IP of the link @deprecated"
    destinationIp: String @deprecated(reason: "Use ipinfo.ip instead")
    "List of directories in the link in the format of [directory1, directory2] @deprecated"
    directories: [String] @deprecated(reason: "Use path instead")
    "contains the link's favicon information"
    favicon: String
    "fragment of the link after the # symbol e.g. https://example.com#anchor1"
    fragment: String
    "Full URL of the link"
    full_url: String
    "MD5 hash of the link"
    hash: String
    "contains the link's IP address information like country, city, etc"
    ipinfo: IpInfo
    "domain of the link"
    netloc: String
    "true if the link is active"
    online: Boolean
    "password if present on the link e.g. https://username:password@example.com"
    password: String
    "directory path of the link"
    path: String
    "Port number of if present on the link"
    port: Int
    "http or https protocol"
    protocol: String
    "List of queries in the link in the format of key=value"
    queries: [String]
    "where the link redirects to. If the link is a shortened, this will be the final destination"
    redirect: String
    "List of reports submitted by users"
    reports: [Report]
    "Total number of reports Submitted by users"
    totalReports: Int
    "username if present on the link e.g. https://username:password@example.com"
    username: String
    "Whois Record of the Domain Name"
    whois: Whois
}

type LinkStats {
    link: Link
    scans: Int
    stats: ReportStats
}

type Mutation {
    AdminGetOTP(dialCode: String!, phone: String!): getOTPres!
    AdminsVerifyOTP(dialCode: String!, otp: String!, phone: String!, request_id: String!): verifyOTPres!
    actionOnLink(actionType: ActionTypes!, url: String!): ActionOnLinkResp
    addInventory(domains: [String!], id: ID!): addInvetoryResp!
    addNewCompany(form: CompanyInput!): addNewCompanyRes!
    "Contact Us Form"
    contactUs(email: String!, message: String!, subject: String!): contactUsRes!
    deleteCompany(id: ID!): deleteCompanyResp!
    deleteReport(link: String!): deleteReportResp
    deleteReportById(id: ID!): deleteReportResp!
    "Get OTP for phone number verification"
    getOTP(dialCode: String!, phone: String!): getOTPres!
    reactReport(reaction: ReactionType!, reportId: String!): reportReactionResp
    reportLink(form: reportLinkInput!): reportLinkResp
    "Update Access Token using Refresh Token, Save new Refresh Token in local storage"
    tokenUpdate(RT: String!): updateTokenRes!
    updateCompany(form: updateCompanyInput!, id: ID!): updateCompanyResp!
    updateDomain(form: updateDomainInput!, id: ID!): updateDomainResp!
    "Update User Details"
    updateUser(form: updateUserInput!): updateUserRes!
    """

    Verify OTP for phone number verification and get access token for further requests.
    Mutation will return accessToken and refreshToken. Use refreshToken to get new accessToken.
    """
    verifyOTP(dialCode: String!, location: [Float], otp: String!, phone: String!, request_id: String!): verifyOTPres!
}

type PackageScanCounts {
    packageName: String
    scanCounts: ScanCounts
}

type PartialUser {
    avatar: String
    city: String
    country: String
    fullname: String
    lastLogin: Date
    state: String
    uid: String
    username: String
}

type Query {
    allReports(limit: FilterLimit!, skip: FilterSkip!): allReportsResp
    getAdmin: getAdminResponse
    getCompanines(limit: FilterLimit!, search: String, skip: FilterSkip!): getCompaniesResp
    getCompany(id: ID!): getCompanyResp
    getDomainInfo(domain: String!): getDomainInfoResp
    getDomains(limit: FilterLimit!, search: String, skip: FilterSkip!): getDomainsResp
    getInventory(id: ID!, limit: FilterLimit!, search: String, skip: FilterSkip!): getInventoryResp
    getLinkReports(id: String!, limit: FilterLimit!, search: String, skip: FilterSkip!): getReportsResp
    getLinkStats(id: String!): getLinkStatsResp
    "Get profile upload URL"
    getProfileUploadURL: getProfileUploadURLRes
    getScans(id: ID!, limit: FilterLimit!, search: String, skip: FilterSkip!): getScansResp
    "Get User Details"
    getUser: getUserResponse!
    hello: String
    scanHistory: scanHistoryResp
    scanLink(app: String, location: [Float], meta: String, triggerType: ScanTriggerType!, url: String!): scanLinkResponse!
}

type QuickScan {
    SEOScore: Int
    TLSexpired: Boolean
    contentType: String
    dashes: Int
    doubleSlashRedirect: Boolean
    freeTLD: Boolean
    googleIndex: Boolean
    havingAtSymbol: Boolean
    havingIpAddress: Boolean
    headers: String
    hostingProvider: String
    responseCode: Int
    serverLocation: String
    severity: Int @deprecated(reason: "Use scan.severity instead")
    shorteningService: String
    siteMap: Boolean
    subDomains: Int
    urlLength: Int
    usingTLS: Boolean
}

type Report {
    comment: String
    createdAt: Date
    dislikes: Int
    domain: String
    flag: String
    likes: Int
    link: String
    location: [Float]
    reaction: [ReportReaction]
    reportId: String
    severity: Int
    user: PartialUser
}

type ReportReaction {
    createdAt: Date
    reaction: ReactionType
    user: PartialUser
}

type ReportStats {
    danger: Int
    lowRisk: Int
    safe: Int
    totalReports: Int
    warning: Int
}

type Scan {
    createdAt: Date
    deepScan: DeepScan
    finishedAt: Date
    link: Link
    location: [Float]
    progress: Int
    quickScan: QuickScan
    scanId: String
    severity: Int
    status: ScanStatus
    triggers: Int
}

type ScanCounts {
    fakeweb: Int
    malware: Int
    phishing: Int
    safe: Int
    spam: Int
    totalScans: Int
    unknown: Int
}

type ScanHistory {
    blocked: Int
    byPackage: [PackageScanCounts]
    datedScanCounts: [DatedScanCounts]
    directScans: ScanCounts
    history(filter: HistoryFilter!): [ScanHistoryItem]
    onClickScans: ScanCounts
    scanCounts: ScanCounts
    visited: Int
}

type ScanHistoryItem {
    date: Date
    domain: String
    icon: String
    type: String
    url: String
}

type ScanTrigger {
    app: String
    createdAt: Date
    meta: String
    scan: Scan
    type: ScanTriggerType
}

type SimilarCompanies {
    "Logo of the company"
    icon: String
    "Name of the company"
    name: String
    "Website of the company"
    url: String
}

type User {
    address: String
    avatar: String
    city: String
    country: String
    "Country Dial Code"
    dialcode: String
    dob: Date
    email: String
    "Firebase Cloud Messaging Token for Push Notifications"
    fcmtoken: String
    fullname: String
    gender: Gender
    lastLogin: Date
    "Phone Number"
    phone: String
    pincode: Int
    "Use refresh token to get new access token"
    refreshToken: String
    state: String
    "Unique ID for User"
    uid: String
}

type Whois {
    "Street address of the registrant"
    address: String
    "City of the registrant"
    city: String
    "Company Details Associated with the domain"
    company: CompanyInfo
    "Country of the registrant"
    country: String
    "Date when the domain was created"
    creationDate: Date
    "DNS records of the domain"
    dnsrecords: DNSRecords
    "Dnssec status of the domain"
    dnssec: [String]
    "Domain name"
    domainName: String
    "List of emails in the format of [email1, email2]"
    emails: [String]
    "Date when the domain will expire"
    expirationDate: Date
    "number of links scanned under this domain"
    linkScanned: Int
    "Name of the registrant"
    name: String
    "List of name servers in the format of [server1, server2]"
    nameServers: [String]
    "Organization of the registrant"
    org: String
    "Postal code of the registrant"
    postalCode: String
    "Domain Registrar"
    registrar: String
    "Report summary of the domain"
    reportStats: ReportStats
    "State of the registrant"
    state: String
    "Status of the domain"
    status: String
    "Date when the domain was last updated"
    updatedDate: [Date]
    "If the domain is whitelisted"
    whitelisted: Boolean
    "Whois Server from where the data is fetched"
    whoisServer: String
}

type addInvetoryResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
}

type addNewCompanyRes {
    backgroundUploadUrl: String
    code: Int!
    imageUploadUrl: String
    message: String!
    payload: Companies
    success: Boolean!
}

type allReportsResp {
    code: Int!
    message: String!
    payload: [Report]
    success: Boolean!
}

type contactUsRes {
    code: Int
    message: String
    success: Boolean
}

type deleteCompanyResp {
    code: Int!
    message: String!
    success: Boolean!
}

type deleteReportResp {
    code: Int!
    message: String!
    success: Boolean!
}

type getAdminResponse {
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type getCompaniesResp {
    code: Int!
    message: String!
    payload: [Companies]
    success: Boolean!
    total: Int
}

type getCompanyResp {
    code: Int!
    message: String!
    payload: Companies
    success: Boolean!
}

type getDomainInfoResp {
    code: Int!
    message: String!
    payload: Whois
    success: Boolean!
}

type getDomainsResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
    total: Int
}

type getInventoryResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
    total: Int
}

type getLinkStatsResp {
    code: Int!
    message: String!
    payload: LinkStats
    success: Boolean!
}

type getOTPres {
    code: Int!
    message: String!
    request_id: String
    success: Boolean!
}

type getProfileUploadURLRes {
    code: Int!
    message: String!
    payload: String
    success: Boolean!
}

type getReportsResp {
    code: Int!
    message: String!
    payload: [linkReport]
    success: Boolean!
    total: Int
}

type getScansResp {
    code: Int!
    message: String!
    payload: [Scan]
    success: Boolean!
    total: Int
}

type getUserResponse {
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type linkReport {
    Report: Report
    user: User
}

type reportLinkResp {
    code: Int!
    message: String!
    payload: Report
    success: Boolean!
}

type reportReactionResp {
    code: Int!
    message: String!
    payload: Report
    success: Boolean!
}

type scanHistoryResp {
    code: Int
    message: String
    payload: ScanHistory
    success: Boolean
}

type scanLinkResponse {
    code: Int
    message: String
    payload: ScanTrigger
    success: Boolean
}

type updateCompanyResp {
    backgroundUploadUrl: String
    code: Int!
    imageUploadUrl: String
    message: String!
    payload: Companies
    success: Boolean!
}

type updateDomainResp {
    code: Int!
    message: String!
    payload: Whois
    success: Boolean!
}

type updateTokenRes {
    accessToken: String
    code: Int
    message: String
    payload: User
    success: Boolean
}

type updateUserRes {
    code: Int
    message: String
    payload: User
    success: Boolean
}

type verifyOTPres {
    accessToken: String
    code: Int
    message: String
    payload: User
    success: Boolean
}

enum ActionTypes {
    BLOCK
    UNSAFE_VIST
    VISIT
}

enum Gender {
    FEMALE
    MALE
    OTHERS
}

enum ReactionType {
    dislike
    like
}

enum ScanStatus {
    error
    finished
    scanning
}

enum ScanTriggerType {
    clipboard
    default_browser
    manual
    network
    notification
}

"Date custom scalar type"
scalar Date

"Email custom scalar type"
scalar Email

"Performs input checking in limit field"
scalar FilterLimit

"Performs input checking in skip field"
scalar FilterSkip

input CompanyInput {
    background: String!
    category: String!
    ceo: String!
    domain: String
    email: String
    facebook: String
    founded: String!
    headerquarters: String!
    image: String!
    instagram: String
    linkedin: String
    name: String!
    phone: String
    rank: Int!
    subtitle: String!
    twitter: String
    verified: Boolean!
    website: String
    youtube: String
}

input HistoryFilter {
    endDate: Date
    limit: FilterLimit!
    skip: FilterSkip!
    startDate: Date
}

input reportLinkInput {
    comment: String!
    flag: String
    link: String!
    location: [Float]
    severity: Int!
}

input updateCompanyInput {
    background: String
    category: String
    ceo: String
    domain: String
    email: String
    facebook: String
    founded: String
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    subtitle: String
    twitter: String
    verified: Boolean
    website: String
    youtube: String
}

input updateDomainInput {
    creationDate: Date
    expirationDate: Date
    registrar: String
    status: String
    whitelisted: Boolean
}

input updateUserInput {
    "Street Address"
    address: String
    city: String
    country: String
    "Accepts Date in ISO format like 1996-12-07T18:30:00.000Z or timestamp like 849983400000"
    dob: Date
    "Email address of the user"
    email: String
    "Firebase Cloud Messaging Token for Push Notifications"
    fcmtoken: String
    "Full Name of the user"
    fullname: String
    gender: Gender
    "GPS location of the user in the format [longitude, latitude]"
    location: [Float]
    pincode: Int
    state: String
}

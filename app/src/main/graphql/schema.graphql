# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"convert lower case to uppercase"
directive @upper on FIELD_DEFINITION

"required Authorization header with valid Access Token"
directive @auth on FIELD_DEFINITION

"required Authorization header with valid Access Token and Admin role"
directive @admin on FIELD_DEFINITION

interface ICompanyInfo {
    background: String
    category: String
    ceo: String
    companyId: String!
    domain: String
    email: String
    facebook: String
    founded: Date
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    subtitle: String
    totalScans: Int
    twitter: String
    verified: Boolean!
    website: String
    youtube: String
}

type Action {
    createdAt: Date
    link: String
    type: ActionTypes
}

type ActionOnLinkResp {
    code: Int
    message: String
    payload: Action
    success: Boolean
}

type Companies {
    background: String
    category: String
    ceo: String
    companyId: String!
    domain: String
    email: String
    facebook: String
    founded: Date
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    subtitle: String
    totalScans: Int
    twitter: String
    verified: Boolean!
    website: String
    whois: [Whois]
    youtube: String
}

type CompanyInfo implements ICompanyInfo {
    background: String
    category: String
    ceo: String
    companyId: String!
    domain: String
    email: String
    facebook: String
    founded: Date
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    similarCompanies: [SimilarCompanies]
    subtitle: String
    totalScans: Int
    twitter: String
    verified: Boolean!
    website: String
    youtube: String
}

type DNSRecords {
    A: [String]
    AAAA: [String]
    CNAME: [String]
    MX: [String]
    NS: [String]
    SOA: [String]
    TXT: [String]
}

type DatedScanCounts {
    date: Date
    scanCounts: ScanCounts
}

type DeepScan {
    about_us: String
    author: String
    contact_us: String
    description: String
    google_site_verification: String
    heading: [String]
    keywords: String
    metaTags: String
    name: String
    og_image: String
    og_type: String
    robots: String
    title: String
}

type IpInfo {
    city: String
    country: String
    country_name: String
    hostname: String
    ip: String
    isEU: Boolean
    latitude: String
    loc: String
    longitude: String
    org: String
    postal: String
    region: String
    timezone: String
}

type Link {
    destinationIp: String
    directories: [String]
    favicon: String
    fragment: String
    full_url: String
    hash: String
    hostname: String
    ipinfo: IpInfo
    netloc: String
    online: Boolean
    params: String
    password: String
    path: String
    port: Int
    protocol: String
    queries: [String]
    query: String
    redirect: String
    reports: [Report]
    totalReports: Int
    username: String
    whois: Whois
}

type LinkStats {
    link: Link
    scans: Int
    stats: ReportStats
}

type Mutation {
    AdminGetOTP(dialCode: String!, phone: String!): getOTPres!
    AdminsVerifyOTP(dialCode: String!, otp: String!, phone: String!, request_id: String!): verifyOTPres!
    actionOnLink(actionType: ActionTypes!, url: String!): ActionOnLinkResp
    addInventory(domains: [String!], id: ID!): addInvetoryResp!
    addNewCompany(form: CompanyInput!): addNewCompanyRes!
    contactUs(email: String!, message: String!, subject: String!): contactUsRes!
    createUser(form: createUserInput!): createUserResponse!
    deleteCompany(id: ID!): deleteCompanyResp!
    deleteReport(link: String!): deleteReportResp
    deleteReportById(id: ID!): deleteReportResp!
    getOTP(dialCode: String!, phone: String!): getOTPres!
    login(secret: String!, username: String!): loginResponse!
    reactReport(reaction: ReactionType!, reportId: String!): reportReactionResp
    reportLink(form: reportLinkInput!): reportLinkResp
    tokenUpdate(RT: String!): updateTokenRes!
    updateCompany(form: updateCompanyInput!, id: ID!): updateCompanyResp!
    updateDomain(form: updateDomainInput!, id: ID!): updateDomainResp!
    updateUser(form: updateUserInput!): updateUserRes!
    verifyOTP(dialCode: String!, location: [Float], otp: String!, phone: String!, request_id: String!): verifyOTPres!
}

type PackageScanCounts {
    packageName: String
    scanCounts: ScanCounts
}

type PartialUser {
    avatar: String
    city: String
    country: String
    fullname: String
    lastLogin: Date
    state: String
    uid: String
    username: String
}

type Query {
    allReports(limit: FilterLimit!, skip: FilterSkip!): allReportsResp
    getAdmin: getAdminResponse
    getCompanines(limit: FilterLimit!, search: String, skip: FilterSkip!): getCompaniesResp
    getCompany(id: ID!): getCompanyResp
    getDomainInfo(domain: String!): getDomainInfoResp
    getDomains(limit: FilterLimit!, search: String, skip: FilterSkip!): getDomainsResp
    getInventory(id: ID!, limit: FilterLimit!, search: String, skip: FilterSkip!): getInventoryResp
    getLinkReports(id: String!, limit: FilterLimit!, search: String, skip: FilterSkip!): getReportsResp
    getLinkStats(id: String!): getLinkStatsResp
    getScans(id: ID!, limit: FilterLimit!, search: String, skip: FilterSkip!): getScansResp
    getUsers: getUserResponse!
    hello: String
    scanHistory: scanHistoryResp
    scanLink(app: String, location: [Float], meta: String, triggerType: ScanTriggerType!, url: String!): scanLinkResponse!
}

type QuickScan {
    SEOScore: Int
    TLSexpired: Boolean
    contentType: String
    dashes: Int
    doubleSlashRedirect: Boolean
    freeTLD: Boolean
    googleIndex: Boolean
    havingAtSymbol: Boolean
    havingIpAddress: Boolean
    headers: String
    hostingProvider: String
    responseCode: Int
    serverLocation: String
    severity: Int @deprecated(reason: "Use scan.severity instead")
    shorteningService: String
    siteMap: Boolean
    subDomains: Int
    urlLength: Int
    usingTLS: Boolean
}

type Report {
    comment: String
    createdAt: Date
    dislikes: Int
    domain: String
    flag: String
    likes: Int
    link: String
    location: [Float]
    reaction: [ReportReaction]
    reportId: String
    severity: Int
    user: PartialUser
}

type ReportReaction {
    createdAt: Date
    reaction: ReactionType
    user: PartialUser
}

type ReportStats {
    danger: Int
    lowRisk: Int
    safe: Int
    totalReports: Int
    warning: Int
}

type Scan {
    createdAt: Date
    deepScan: DeepScan
    finishedAt: Date
    link: Link
    location: [Float]
    progress: Int
    quickScan: QuickScan
    scanId: String
    severity: Int
    status: ScanStatus
    triggers: Int
}

type ScanCounts {
    fakeweb: Int
    malware: Int
    phishing: Int
    safe: Int
    spam: Int
    totalScans: Int
    unknown: Int
}

type ScanHistory {
    blocked: Int
    byPackage: [PackageScanCounts]
    datedScanCounts: [DatedScanCounts]
    directScans: ScanCounts
    history(filter: HistoryFilter!): [ScanHistoryItem]
    onClickScans: ScanCounts
    scanCounts: ScanCounts
    visited: Int
}

type ScanHistoryItem {
    date: Date
    domain: String
    icon: String
    type: String
    url: String
}

type ScanTrigger {
    app: String
    createdAt: Date
    meta: String
    scan: Scan
    type: ScanTriggerType
}

type SimilarCompanies {
    icon: String
    name: String
    url: String
}

type User {
    address: String
    avatar: String
    city: String
    country: String
    dialcode: String
    email: String
    fcmtoken: String
    fullname: String
    gender: String
    lastLogin: Date
    phone: String
    pincode: Int
    refreshToken: String
    state: String
    uid: String
    username: String
}

type Whois {
    address: String
    city: String
    company: CompanyInfo
    country: String
    creationDate: Date
    dnsrecords: DNSRecords
    dnssec: [String]
    domainName: String
    emails: [String]
    expirationDate: Date
    linkScanned: Int
    name: String
    nameServers: [String]
    org: String
    postalCode: String
    registrar: String
    reportStats: ReportStats
    state: String
    status: String
    updatedDate: [Date]
    whitelisted: Boolean
    whoisServer: String
}

type addInvetoryResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
}

type addNewCompanyRes {
    backgroundUploadUrl: String
    code: Int!
    imageUploadUrl: String
    message: String!
    payload: Companies
    success: Boolean!
}

type allReportsResp {
    code: Int!
    message: String!
    payload: [Report]
    success: Boolean!
}

type contactUsRes {
    code: Int
    message: String
    success: Boolean
}

type createUserResponse {
    accessToken: String
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type deleteCompanyResp {
    code: Int!
    message: String!
    success: Boolean!
}

type deleteReportResp {
    code: Int!
    message: String!
    success: Boolean!
}

type getAdminResponse {
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type getCompaniesResp {
    code: Int!
    message: String!
    payload: [Companies]
    success: Boolean!
    total: Int
}

type getCompanyResp {
    code: Int!
    message: String!
    payload: Companies
    success: Boolean!
}

type getDomainInfoResp {
    code: Int!
    message: String!
    payload: Whois
    success: Boolean!
}

type getDomainsResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
    total: Int
}

type getInventoryResp {
    code: Int!
    message: String!
    payload: [Whois]
    success: Boolean!
    total: Int
}

type getLinkStatsResp {
    code: Int!
    message: String!
    payload: LinkStats
    success: Boolean!
}

type getOTPres {
    code: Int!
    message: String!
    request_id: String
    success: Boolean!
}

type getReportsResp {
    code: Int!
    message: String!
    payload: [linkReport]
    success: Boolean!
    total: Int
}

type getScansResp {
    code: Int!
    message: String!
    payload: [Scan]
    success: Boolean!
    total: Int
}

type getUserResponse {
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type linkReport {
    Report: Report
    user: User
}

type loginResponse {
    accessToken: String
    code: Int!
    message: String!
    payload: User
    success: Boolean!
}

type reportLinkResp {
    code: Int!
    message: String!
    payload: Report
    success: Boolean!
}

type reportReactionResp {
    code: Int!
    message: String!
    payload: Report
    success: Boolean!
}

type scanHistoryResp {
    code: Int
    message: String
    payload: ScanHistory
    success: Boolean
}

type scanLinkResponse {
    code: Int
    message: String
    payload: ScanTrigger
    success: Boolean
}

type updateCompanyResp {
    backgroundUploadUrl: String
    code: Int!
    imageUploadUrl: String
    message: String!
    payload: Companies
    success: Boolean!
}

type updateDomainResp {
    code: Int!
    message: String!
    payload: Whois
    success: Boolean!
}

type updateTokenRes {
    accessToken: String
    code: Int
    message: String
    payload: User
    success: Boolean
}

type updateUserRes {
    code: Int
    message: String
    payload: User
    success: Boolean
}

type verifyOTPres {
    accessToken: String
    code: Int
    message: String
    payload: User
    success: Boolean
}

enum ActionTypes {
    BLOCK
    UNSAFE_VIST
    VISIT
}

enum ReactionType {
    dislike
    like
}

enum ScanStatus {
    error
    finished
    scanning
}

enum ScanTriggerType {
    clipboard
    default_browser
    manual
    network
    notification
}

"Date custom scalar type"
scalar Date

"Email custom scalar type"
scalar Email

"Performs input checking in limit field"
scalar FilterLimit

"Performs input checking in skip field"
scalar FilterSkip

input CompanyInput {
    background: String!
    category: String!
    ceo: String!
    domain: String
    email: String
    facebook: String
    founded: String!
    headerquarters: String!
    image: String!
    instagram: String
    linkedin: String
    name: String!
    phone: String
    rank: Int!
    subtitle: String!
    twitter: String
    verified: Boolean!
    website: String
    youtube: String
}

input HistoryFilter {
    endDate: Date
    limit: FilterLimit!
    skip: FilterSkip!
    startDate: Date
}

input createUserInput {
    dialcode: String!
    fcmtoken: String
    fullname: String!
    location: [Float]
    phone: String!
    secret: String!
    token: String
    username: String!
}

input reportLinkInput {
    comment: String!
    flag: String
    link: String!
    location: [Float]
    severity: Int!
}

input updateCompanyInput {
    background: String
    category: String
    ceo: String
    domain: String
    email: String
    facebook: String
    founded: String
    headerquarters: String
    image: String
    instagram: String
    linkedin: String
    name: String
    phone: String
    rank: Int
    subtitle: String
    twitter: String
    verified: Boolean
    website: String
    youtube: String
}

input updateDomainInput {
    creationDate: Date
    expirationDate: Date
    registrar: String
    status: String
    whitelisted: Boolean
}

input updateUserInput {
    address: String
    avatar: String
    city: String
    country: String
    email: String
    fcmtoken: String
    fullname: String
    location: [Float]
    pincode: Int
    secret: String
    state: String
    username: String
}
